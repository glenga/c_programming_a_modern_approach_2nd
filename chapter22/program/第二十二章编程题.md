# 第二十二章编程题

1. 扩展22.2节的`canopen.c`程序,以便用户可以把任意数量的文件名放置在命令行中:

   ```
   canopen foo bar baz
   ```

   这个程序应该为每个文件分别显示出`can be opended`消息或者`can't be opened`消息。如果一个或多个文件无法打开,程序以`EXIT_FAILURE`状态终止。

   

2. 编写程序,把文件中的所有字母转换成大写形式(非字母字符不改变),程序应从命令行获取文件名并把输出写到`stdout`中。

   

3. 编写一个名为`fcat`的程序,通过把任意数量的文件写到标准输出中而把这些文件一个接一个地“拼接”起来,而且文件之间没有间隙。例如,下列命令将在屏幕上显示文件`f1.c`,`f2.c`和`f3.c`:

   ```
   fcat f1.c f2.c f3.c
   ```

   如果任何文件都无法打开,那么程序`fcat`应该发出出错消息。提示:因为每次只可以打开一个文件,所以程序`fcat`只需要一个文件指针变量。一旦对一个文件完成操作,程序`fcat`在打开下一个文件时可以使用同一个文件指针变量。

   

4. (a)编写程序统计文本文件中字符的数量。

   (b)编写程序统计文本文件中单词的数量。(所谓“单词”指的是不含空白字符的任意序列。)

   (c)编写程序统计文本文件中行的数量。

   要求每一个程序都通过命令行获得文件名。

   

5. 20.1节中的程序`xor.c`拒绝对原始格式或加密格式中是控制字符的字节进行加密。现在可以摆脱这种限制了。修改此程序使输入文件名和输出文件名都是命令行参数。以二进制模式打开这两个文件,并且把用来检查原始字符或加密字符是否是控制字符的判断删除。

   

6. 编写程序,按字节方式和字符方式显示文件的内容。用户通过命令行指定文件名。程序用于显示2.1,节的`pun.c`文件时,输出如下:

   ```
   Offset              Bytes              Characters
   ------  -----------------------------  ----------
        0  23 69 6E 63 6C 75 64 65 20 3C  #include <
       10  73 74 64 69 6F 2E 68 3E 0D 0A  stdio.h>..
       20  0D 0A 69 6E 74 20 6D 61 69 6E  ..int main
       30  28 76 6F 69 64 29 0D 0A 7B 0D  (void)..{.
       40  0A 20 20 70 72 69 6E 74 66 28  .  printf
       50  22 54 6F 20 43 2C 20 6F 72 20  "To C, or 
       60  6E 6F 74 20 74 6F 20 43 3A 20  not to C: 
       70  74 68 61 74 20 69 73 20 74 68  that is th
       80  65 20 71 75 65 73 74 69 6F 6E  e question
       90  2E 5C 6E 22 29 3B 0D 0A 20 20  .\n");..  
      100  72 65 74 75 72 6E 20 30 3B 0D  return 0;.
      110  0A 7D                          .}
   ```

   每行分别以字节方式和字符方式显示文件中的10个字节。Offset一栏中的数值表示该行的第一个字节在文件中的位置。只显示打印字符(由`isprint`函数确定),其他字符显示为点。注意,根据字符集和操作系统的不同,文本文件的形式可能不同。上面的示例假设`pun.c`是`Windows`文件,因此在每行的最后有`0D`和`0A` (`ASCII`码的回车和回行符),提示:确保用`"rb"`模式打开文件。

   

7. 在进行文件内容压缩的众多方法中,最简单快捷的方法之一是行程长度编码(`run-length encoding`)方式。这种方法通过用一对字节替换相同的字节序列来进行文件的压缩:第一个字节是重复计数,第二个字节是需要重复的字节。例如,假设待压缩的文件以下列字节序列开始(以十六进制形式显示):

   ```
   46 6F 6F 20 62 61 72 21 21 21 20 20 20 20 20
   ```

   压缩后的文件将包含下列字节:

   ```
   01 46 02 6F 01 20 01 62 01 61 01 72 03 21 05 20
   ```

   如果原始文件包含许多相同字节的长序列,那么行程长度编码的方法非常适用。最差的情况(文件中没有连续的重复字节)下,行程长度编码实际上可能使文件的长度加倍。

   (a)编写名为`compress_file`的程序,此程序使用行程长度编码方法来压缩文件。为了运行程序`compress_file`,将使用下列格式的命令:

   `compress_file`原始文件

   程序`compress_file`将把原始文件的压缩版本写入到`“原始文件.rle"`文件中。例如,命令

   `compress_file foo.txt`

   将会使程序`compress_file`把文件`foo.txt`的压缩版写到名为`foo.txt.rle`的文件中。提示:编程题6描述的程序可以用来调试.

   (b)编写名为`uncompress_file`的程序,此程序是程序`compress_file`的反向操作。程序

   `uncompress_file`的命令格式为

   `uncompress_file compressed-file`

   压缩后的文件(`compressed-file`)扩展名为`.rle`。例如,命令

   `uncompress_file foo.txt.rle`

   将会使程序`uncompress_file`-file打开文件`foo.txt.rle`,并且把未压缩版的内容写入`foo.txt`。如果命令行参数的扩展名不是`.rle`, `uncompress_file`应显示一条出错消息。

   

8. 通过添加两个新的操作来修改16.3节中的`inventory.c`程序: 

   - 在指定文件中保存数据库。
   - 从指定文件中装载数据库。

   分别使用代码a (转储)和r (恢复)来表示这两种操作。与用户的交互应该按照下列显示进行: 

   ```
   Enter operation code: d
   Enter name of output file: inventory.dat
   
   Enter operation code: r
   Enter name of input file: inventory.dat
   ```

   

9. 编写程序对由`inventory`程序存储的含有零件记录的两个文件进行合并(见编程题8),假设每个文件中的记录都是根据零件编号进行排序的,且我们希望结果文件也应是排好序的。如果两个文件中存在编号相同的零件,那么要对记录中存储的数量进行合并。(作为一致性的检查,程序要比较零件的名称,并且在不匹配时显示出错消息。)程序从命令行获取输入文件名以及合并后的文件名。

   

10. 修改17.5节中的程序`inventory2.c`,方法是添加编程题8中描述的a (转储)操作和r(恢复)操作。因为零件的结构不存储在数组中,所以d操作无法通过单独一个`fwrite`调用来保存所有内容。因而,它需要访问链表中的每个结点,把零件的编号、名称以及现有的零件数量保存到文件中。(不保存指针next,因为一旦程序终止,这一指针就会不再有效。)当程序从文件中读取零件时, r操作将重新构建列表(每次恢复一个结点)。

    

11. 编写程序从命令行读取日期,并且按照下列格式显示出来: 

    ```
    September 13, 2010
    ```

    允许用户以`9-13-2010`或者`9/13/2010`的形式录入日期,并假设日期中没有空格。如果没有按照指定格式录入日期,那么程序显示出错消息。提示:使用`sscanf`函数从命令行参数中提取出月、日和年的信息。

    

12. 修改第3章的编程题2,让程序从文件中读取一系列数据项并按列显示数据。文件的每一行具有如下形式: 

    数据项,价格,月/日/年

    例如,假设文件包含下列两行:

    ```
    583,13.5,10/24/2005
    3912,599.99,7/27/2008
    ```

    程序的输出形式如下:

    ```
    Item            Unit            Purchase
                    Price           Date
    583             $  13.50        10/24/2005
    3912            $ 599.99        07/27/2008
    ```

    程序从命令行获取文件名。

     

13. 修改第5章的编程题8,让程序从名为`flights. dat`的文件中获取起飞时间和抵达时间。文件的每一行先给出起飞时间再给出抵达时间,中间用一个或多个空格隔开。时间用24小时制表示。例如,如果文件包含的是原题中的航班信息,则`flights.dat`如下: 

    ```
    8:00 10:16
    9:43 11:52
    11:19 13:31
    12:47 15:00
    14:00 16:08
    15:45 17:55
    19:00 12:20
    21:45 23:58
    ```

    

14. 修改第8章的编程题15,让程序提示用户输入包含待加密消息的文件名:

    ```
    Enter name of file to be encrypted: message.txt
    Enter shift amount (1-25): 3
    ```

    接下来,程序把加密后的消息写入另一个文件中,该文件在所读取的文件名之后加上扩展名`.enc`.在上面的例子中,原始文件名为`message. txt`,所以加密消息存储在名为`message.txt. enc`的文件中。待加密文件的大小不限,文件中每行的长度也不限。 

    

15. 修改15.3节的`justify`程序,使其从一个文本文件中读取并写入另一个文本文件。程序从命令行获取这两个文件名。

    

16. 修改22.4节的`fcopy.c`程序,使其用`fread`和`fwrite`来复制文件,复制时使用512字节的块。(当然,最后一个块包含的字节数可能少于512.)

    

17. 编写程序,从文件中读取一系列电话号码并以标准格式显示。文件的每一行只包含一个电话号码,但可能存在多种格式。可以假定每行包含10个数字,可能夹杂着其他字符(可以忽略),例如,假定文件包含如下内容: 

    ```
    404.817.6900
    (215) 686-1776
    312-746-6000
    877 275 5273
    6173434200
    ```

    程序的输出如下：

    ```
    (404) 817-6900
    (215) 686-1776
    (312) 746-6000
    (877) 275-5273
    (617) 343-4200
    ```

    

18. 编写程序从文本文件中读取整数,文本文件的名字由命令行参数给出。文件的每一行可以包含任意数量的整数(也可以没有),中间用一个或多个空格隔开。程序显示文件中最大的数、最小的数以及中值(整数有序情况下最接近中间的那个数),如果文件包含偶数个整数,中间会有两个整数,程序显示它们的均值(向下取整)。可以假定文件包含的整数个数不超过10000,提示:把整数存储在数组中并对其排序。

    

19. (a)编写程序把`Windows`的文本文件转换成`UNIX`的文本文件。(见22.1节关于两者区别的讨论。)

    (b)编写程序把`UNIX`的文本文件转换成`Windows`的文本文件。

    每种情况下都从命令行获取两个文件的名字。提示:以`"rb"`模式打开输入文件,以`"wb"`模式打开输出文件。