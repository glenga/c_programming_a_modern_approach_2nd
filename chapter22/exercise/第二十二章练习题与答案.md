# 第二十二章 输入/输出

1. 指出下列每个文件更可能包含文本数据还是二进制数据。

   (a) C编译器产生的目标代码文件。

   (b) C编译器产生的程序列表。

   (c) 从一台计算机发送到另一台计算机的电子邮件消息。

   (d) 含有图形图像的文件。

   #### 答案

   (a) 二进制文件

   (b) 文本文件

   (c) 文本文件

   (d) 二进制文件  

   

2. 指出在下列每种情况下最可能把哪种模式字符串传递给`fopen`函数。

   (a) 数据库管理系统打开含有将被更新的记录的文件。

   (b) 邮件程序打开存有消息的文件以便可以在文件末尾添加额外的消息。

   (c) 图形程序打开含有将被显示在屏幕上的图片的文件。

   (d) 操作系统命令解释器打开含有将被执行的命令的"shell脚本” (或者“批处理文件")。

   #### 答案

   (a) `rb+`

   (b) `a`

   (c) `rb`

   (d) `r`

   

3. 找出下列程序段中的错误,并说明如何修正。

   ```c
   FILE *fp;
   if (fp = fopen (filename, "r")){
       // 读取字符直到文件末尾
   }
   fclose (fp);
   ```

   #### 答案

   ```c
   FILE *fp;
   if (fp = fopen (filename, "r")){
       // 读取字符直到文件末尾
   }else{
       fprintf(stderr, "Error open file: %s\n", filename);
       exit(EXIT_FAILURE);
   }
   fclose (fp);
   ```

   

4. 请指出如果`printf`函数用`%#012.5g`作为转换说明来执行显示操作,下列数字显示的形式。

   (a) `83.7361`
   (b) `29748.6607`
   (c) `1054932234.0`
   (d) `0.0000235218`

   #### 答案

   (a) `00000083.736`

   (b) `00000029749.`

   (c) `01.0549e+009` 

   (d) `02.3522e-005`

   

5. `printf`函数的转换说明`%.4d`和`%04d`有区别吗?如果有,请说明区别是什么。

   #### 答案

   有区别,  如果给点变量不足4位,`%.4d`会用空白符补足4位,而`%04d`会用`0`补足4位.

   

6. 编写`printf`函数的调用,要求如果变量`widget` (`int`类型)的值为1,则显示1 `widget`;如果值为`n`,则显示出`n widgets`。不允许使用if语句或任何其他语句,答案必须是单独的一个`printf`调用。

   #### 答案

   ```c
   printf( "%d widget%s.\n", widget, widget == 1 : "\n" ? "s\n");
   ```

   

7. 假设按照下列形式调用`scanf`函数:

   ```c
   n = scanf("%d%f%d", &i, &x, &j);
   ```

   (其中, `i`、`j`和`n`都是`int`类型变量,而x是`float`类型变量。)假设输入流含有下面所示的字符,请指出这个调用后`i`、`j`、`n`和`x`的值。此外,请说明一下这个调用会消耗掉哪些字符。

   (a) `10●20●30¤`
   (b) `1.0●2.0●3.0¤`
   (c) `0.1●0.2●0.3¤`
   (d) `.1●.2●.3¤`

   注意: ●时空白符, ¤是换行符

   #### 答案

   (a) ~~`10●20●30`~~`¤`

   n=3, i=10, x=20.0, j=30 

   (b) ~~`1.0●2`~~`.0●3.0¤` 

   n=3, i=1, x=0.0, j=2

   (c) ~~`0.1●0`~~`.2●0.3¤`

   n=3, i=0, x=0.1, j=0 

   (d) `.1●.2●.3¤`

   n=0, i=未定义, x=未定义, j=未定义

   

8. 在前面几章中,当希望跳过空白字符而读取非标准空白字符时,已经使用过`scanf`函数的`" %c"`格式串。而一些程序员用`"%1s"`来代替。这两种方法等效吗?如果不等效,区别是什么?

   #### 答案

   不等效

   `" %c"`会得到一个字符

   `"%1s"`会得到一个字符串, 字符的后面会被添加了`\0`

   

9. 如果要想从标准输入流中读取一个字符,下列调用方式哪种是无效的?

   (a) `getch()`
   (b) `getchar()`
   (c) `getc(stdin)`
   (d) `fgetc(stdin)`

   #### 答案

   (a) 非标准库函数, 仅`windows`系统有用.

   

10. 程序`fcopy`有一个小缺陷:当它向目标文件写入时无法检查错误。虽然在写操作过程中错误是极少的,但是偶尔会发生(比如,磁盘可能会变满)。假设希望一旦发生错误,程序可以显示一条消息并立刻终止,请说明如何为`fcopy.c`添加遗漏的错误检查。

    #### 答案

    ```c
    ...
      while ((ch = getc(source_fp)) != EOF) {
        // 检查putc函数的执行结果
        if (EOF == putc(ch, dest_fp)) {
          fprintf(stderr, "writting to file failed.\n");
        }
      }
    ...
    ```

    

11. 在程序`fcopy.c`中出现了下列循环:

    ```c
    while ((ch = getc(source_fp)) != EOF)
      putc(ch, dest_fp);
    ```

    假设省略表达式`ch = getc (source_fp)`两边的圆括号:

    ```c
    while (ch = getc(source_fp) != EOF)
      putc(ch, dest_fp);
    ```

    程序可以无错通过编译吗?如果可以,那么运行时程序会做些什么呢?

    #### 答案

    可以通过编译, 但是关系运算符的优先级高于赋值运算符,所以ch的值始终位1,死循环

    

12. 找出下列函数中的错误,并说明加何修正 .

    ```c
    int count_periods(const char *filename){
        FILE *fp;
        int n = 0;
        if ((fp = fopen(filename, "r")) != NULL) {
            while (fgetc(fp) != EOF)
                if (fgetc(fp) == '.')
                    n++;
            fclose(fp);
        }
        return n;
    }
    ```

    #### 答案

    `getchar`、`getc`、`fgetc`这类函数会消耗流中的字符，`while`循环中一次消耗了2个字符，所以有一半的字符没有被检测到.

    ```c
    int count_periods(const char *filename){
        FILE *fp;
        int n = 0, ch;
        if ((fp = fopen(filename, "r")) != NULL) {
            while ((ch = fgetc(fp)) != EOF)
                if (ch == '.')
                    n++;
            fclose(fp);
        }
        return n;
    }
    ```

    

13. 编写下列函数:

    ```c
    int line_length(const char *filename, int n);
    ```

    函数应返回名为`filename`的文本文件中第n行的长度(假定文件的第一行是行1),如果该行不存在,函数返回0.

    #### 答案

    见`exercise22.13.c`

    

14. (a)编写自己版本的`fgets`函数,使此函数的操作尽可能与实际的`fgets`函数相同。特别是一定要确保函数具有正确的返回值。为了避免和标准库发生冲突,请不要把自己编写的函数也命名为`fgets`。

    (b)请编写自己版本的`fputs`函数,规则和(a)要求的一样`fputs`。

    #### 答案

    见`exercise22.14.c`

    

15. 编写`fseek`函数的调用来在二进制文件中执行下列文件定位操作,其中,二进制文件的数据以64字节“记录”的形式进行排列。采用`fp`作为下列每种情况中的文件指针。

    (a) 移动到记录n的开始处(假设文件中的首记录为记录0)。
    (b) 移动到文件中最后一条记录的开始处。
    (c) 向前移动一条记录。
    (d) 向后移动两条记录。

    #### 答案

    (a) `fseek(fp, 64L * n, SEEK_SET);`

    (b) `fseek(fp, -64L, SEEK_END);`

    (c) `fseek(fp, 64L, SEEK_CUR);`

    (d) `fseek(fp, -2 * 64L, SEEK_CUR);`

    

16. 假设`str`是包含“销售排行”的字符串,它紧跟在符号#的后面(#的前面可能有其他字符,销售排行的后面也可能有其他字符)。销售排行是一系列的十进制数字,可能包含逗号,示例如下：

    ```
    989
    24,675
    1,162,620
    ```

    编写`sscanf`的调用,提取出销售排行(不要#号)并将其存储在一个名为`sales_rank`的字符串变量中。

    #### 答案
    
    ```c
    sscanf(str, str[0] == '#' ? "%*[#]%[0123456789,]" : "%*[^#]*[#]%[0123456789,]", sales_rank);
    ```
    
    `%*`  `*`表示占用的位宽， 在后面的参数列表中必须指出占用的位数n，省略了n即不显示

