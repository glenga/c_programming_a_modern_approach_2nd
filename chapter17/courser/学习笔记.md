# 第十七章 指针的高级应用



### 1. 内存分配函数, 需要包含 `stdlib.h`

- `malloc`函数--分配内存块,"但是不对内存块进行初始化。

- `calloc`函数--分配内存块,并且对内存块进行清零。

- `realloc`函数-调整先前分配的内存块大小。 

  内存分配函数返回的是`void`类型，`void`类型可以自动转换成任何类型，没必要进行强制类型转换。内存分配有可能失败所以必须对分配函数进行空指针检查。

  `free`函数的实际参数必须是先前由内存分配函数返回的指针。参数也可以是空指针，此时`free`函数调用不起作用。

  `free`了一个指针`P`，要及时的设置指针`P`指向`NULL`，以免产生悬空指针。

  

### 2. 链表遍历常用法

- 不需要修改链表，仅用一个指针变量就可以遍历

- 需要修改链表节点，一般情况下需要一前一后两个变量比较好理解。

  

### 3. 指向指针的指针

为什么需要指向指针的指针？因为c语言只支持传值调用，**如果不想通过中间变量返回来改变一个变量的值**，唯一能做的就是传递这个变量的地址，使用取地址操作符&：

```c
void foo(int *i);  // 函数的声明形式

int i;
scanf("%d", &i);

foo(&i);   //函数的调用形式

```

换成指针变量：

```c
char *str;

// 如果不通过中间变量返回来改变指针的值，我们需要使用取地址操作符调用函数
foo(&str);

// 显然这个时候我们的声明函数就必须是对一个指针取地址，用通俗的话来说就是指向指针的指针
void foo(char **str);
```

牢记两句话：

- c语言只支持传值调用
- 通过取地址操作符间接操作变量的值

所以当你的函数形参是指针变量时，也仅仅时复制了原变量的值。



### 4. `qsort`函数

- 注意`compare`函数中`void *`参数的类型转换

  

### 5. 受限指针`restrict`

`restict`修饰的指针变量`P`指向的对象具有唯一绑定关系：指针P与对象之间的唯一绑定。



### 6. 灵活数组

```c
struct nstring{
    int len;
    char chars[];
};
```

- 数组只能是结构体的最后一个成员
- 灵活数组是不完整的类型，缺少需要分配内存大小的信息
- 复制包含零或数组成员的结构时，结构中灵活数组不会被复制。
- 灵活数组不能作为其它结构的成员和数组的元素，因为他时不完整类型，无法分配固定的内存大小。









