# 第八章编程题



1. 修改8.1节的程序`repdigit.c`， 使其可以显示出哪些数字有重复，如果有的话：

   ```
   Enter a number: 939577
   Repeated digit(s): 7 9
   ```



2.修改8.1节的程序`repdigit.c`， 使其打印一份列表，显示出每个数字在数中出现的次数：

```
Enter a number: 41271092
Digit:			0 1 2 3 4 5 6 7 8 9 
Occurrences:	1 2 2 0 1 0 0 1 0 1
```



3. 修改8.1节的程序`repdigit.c`， 使得用户可以录入多个数进行重复数字判断， 当用户录入的数小于或等于`0`时，程序终止。



4. 修改8.1节的程序`reverse.c`， 利用表达式`(int) (sizeof(a) / sizeof(a[0]))`， 或具有相同值的宏来计算数组的长度。



5. 修改8.1节的程序`interest.c`， 使得修改后的程序可以每月整合以此利息， 而不是每年整合一次利息。 不要改变程序的输出格式，余额仍按每年以此的时间间隔显示。



6. 网络新手的原型是一个名为`BIFF`的人， 他有一种独特的编写消息的方法。 下面是一条常见的`BIFF`公告：

   ```
   H3Y DUD3, C 15 R1LLY COOL!!!!!!!!!
   ```

   编写一个`BIFF`过滤器，它可以读取用户录入的消息并把此消息翻译成`BIFF`的表达风格：

   ```
   Enter message: Hey dude, C is rilly cool
   In BIFF-speak: H3Y DUD3, C 15 R1LLY COOL!!!!!!!!!
   ```

   程序需要把消息转换成大写字母， 用数字代替特定的字母（A-4,B-8,E-3,I-1,O-0,S-5）， 然后添加10个左右的感叹号。 *提示*：把原始消息存储在一个字符数组中，然后从数组头开始逐个翻译并显示字符。



7. 编写程序读取一个`5x5`的整数数组，然后显示出每行的和与每列的和。

   ```
   Enter row 1: 8 3 9 0 10
   Enter row 2: 3 5 17 1 1
   Enter row 3: 2 8 6 23 1
   Enter row 4: 15 7 3 2 9
   Enter row 5: 6 14 2 6 0
   
   Row totals: 30 27 40 36 28
   Column totals: 34 37 37 32 21
   ```



8. 修改编程题7， 使其提示用户输入每个学生5门测验的成绩， 一共有5个学生。然后计算每个学生的总分和平均分， 以及每门测验的平均分、高分和低分。



9. 编写程序， 生成一种贯穿`10x10`字符数组（初始化时全为字符'.'）的“随机步法”。 程序必须随机地从一个元素“走到”另一个元素， 每次都向上、向下、向左或向右移动一个元素位置。 已访问过的元素按照访问顺序用字母A掉Z进行标记。下面是一个输出示例：

   ```
   A . . . . . . . . .
   B C D . . . . . . .
   . F E . . . . . . .
   H G . . . . . . . .
   I . . . . . . . . .
   J . . . . . . . Z .
   K . . R S T U V Y .
   L M P Q . . . W X .
   . N O . . . . . . .
   . . . . . . . . . .
   ```

   *提示*：利用`srand`函数和`rand`函数（见程序*deal.c*）产生随机数， 然后查看此数除以4的余数。 余数一共有`4`种可能的值（`0`,`1`,`2`和`3`），指示下一次移动的`4`种可能方向。 在执行移动之前，需要检查两项内容：一是不能走数组外面，二是不能走到已有字母标记的位置。 只要有一个条件不满足，就得尝试换一个方向移动。如果`4`个方向都堵住了，程序就必须终止了。 下面是提前结束的一个示例：

   ```
   A B G H I . . . . .
   . C F . J K . . . .
   . D E . M L . . . .
   . . . . N O . . . .
   . . W X Y P Q . . .
   . . V U T S R . . .
   . . . . . . . . . .
   . . . . . . . . . .
   . . . . . . . . . .
   . . . . . . . . . .
   ```

   因为`Y`的`4`个方向都堵住了，所以没有地方可以放置下一步的`Z`了。

   

10. 修改第5章的编程题8， 用一个数组储存起飞时间， 另一个数组存储抵达时间， （时间用整数表示，表示从午夜开始的分钟数。） 程序用一个循环搜索起飞时间数组，以找到与用户输入的时间最接近的起飞时间。



11. 修改第7章的编程题4，给输出加上标签：

    ```
    Enter phone number: 1-800-COL-LECT
    In numeric form: 1-800-265-5328
    ```

    在显示电话号码之前， 程序需要将其（以原始格式或数值格式）存储在一个字符数组中。 可以假定电话号码的长度不超过15个字符。



12. 修改第7章的编程题5， 用数组储存字母的面值。 数组有26个元素， 对应字母表中的26个字母。例如， 数组元素0存储1（因为字母A的面值为1）， 数组元素1存储3（因为字母B的面值为3），等等。 每读取输入单词中的一个字母， 程序都会利用该数组确定字符的拼字值。 使用数组初始化式来建立该数组。



13. 修改第7章的编程题11，给输出加上标签：

    ```
    Enter a first and last name: Lloyd Fosdick
    You entered the name: Fosdick, L.
    ```

    在显示姓氏之前，程序需要将其存储在一个字符数组中，可以假定姓氏的长度不超过20个字符。



14. 编写程序颠倒句子中单词的顺序：

    ```
    Enter a sentence: you can cage a swallow can't you?
    Reversal of sentence: you can't swallow a cage can you?
    ```

    *提示*：用循环逐个读取字符， 然后将它们存储在一个一维字符数组中。 当遇到句号，文号或感叹号（称为终止字符时）， 终止循环并把终止字符存储在一个`char`类型变量中。 然后再用一个循环反向搜索数组，找到最后一个单词的起始位置。 显示最后一个单词，然后反向搜索倒数第二个单词。 重复这一过程，直至到达数组的起始位置。最后显示出终止字符。



15. 已知的最古老的一种加密技术是凯撒加密。 该方法把一条消息中的每个字母用字母表中固定距离之后的那个字母替代。 如果越过了字母Z，会绕回到字母表的起始位置。 例如，如果每个字母都用字母表中两个位置之后的字母代替， 那么Y就会被替换为A，Z就被替换为B。 编写程序用凯撒加密方法对消息进行加密。 用户输入待加密的消息和移位计数（字母移动的位置数目）：

    ```
    Enter message to be encrypted: Go ahead, make my day.
    Enter shift amount (1-25): 3
    Encrypted message: Jr dkhdg, pdnh pb gdb.
    ```

    注意，当用户输入26与移位计数的差值时，程序可以对消息进行解密：

    ```
    Enter message to be encrypted: Jr dkhdg, pdnh pb gdb.
    Enter shift amount (1-25): 23
    Encrypted message: Go ahead, make my day.
    ```

    可以假定消息的长度不超过80个字符。不是字母的那些字符不要改动， 此外，加密时不要改变字母的大小写。 *提示*：为了解决前面提到的绕回问题， 可以用表达式`((ch -'A') + n) % 26 + 'A'`计算大写字母的密码， 其中`ch`存储字母，`n`存储移位计数。（小写字母也需要一个类似的表达式。）



16. 编程测试两个单词是否为变位词（相同字母的重新排列）：

    ```
    Enter first word: smartest
    Enter second word: mattress
    The words are anagrams.
    
    Enter first word: dumbest
    Enter second word: stumble
    The words are not anagrams.
    ```

    用一个循环逐个字符第读取第一个单词， 用一个`26`元的整数数组记录每个字母的出现次数。 用另一个循环读取第二个单词， 这次每读取一个字母就把相应数组元素的值减1。 两个循环都应该忽略不是字母的那些字符， 并且不区分大小写。 第二个单词读取完毕后， 再用一个循环检查数组元素是否为全`0`。 如果是全`0`，那么这两个单词就是变位词。 *提示*：可以使用`<ctype.h>`中的函数，如`isalpha`和`tolower`。



17. 编写一个程序打印`nxn`的幻方 （`1`,`2`，...,`n*n`）的方阵排列， 且每行、每行和每条对角线上的和都相等。 由用户指定`n`的值。

    ```
    This program creates a magic square of a specified size.
    The size must be an odd number between 1 and 99.
    Enter size of magic square: 5
       17   24    1    8   15
       23    5    7   14   16
        4    6   13   20   22
       10   12   19   21    3
       11   18   25    2    9
    ```

    把幻方存储在一个二维数组中。 起始时把数`i`放在`0`行的中间， 剩下的数`2`,`3`,...,`n*n`依次向上移动一行并向右移动列。 当可能越过数组边界时需要绕回到数组的另一端。 例如，如需要把下一个数放到`-1`行， 我们就将其存储到`n-1`行（最后一行）； 如果需要把下一个数放到`n`列，我们就将其存储到`0`列。 如果某个特定的数组元素已被占用，那就把该数存储在前一个数的正下方。 如果你的编译器支持变长数组，声明数组有`n`行`n`列，否则声明数组有`99`行`99`列。

